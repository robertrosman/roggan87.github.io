<!-- This Source Code Form is subject to the terms of the Mozilla Public
   - License, v. 2.0. If a copy of the MPL was not distributed with this
   - file, You can obtain one at http://mozilla.org/MPL/2.0/. -->


<!doctype html>
<html>
    <head>
        <meta charset="utf-8">
        <title>Untitled</title>
        <style>
            body {
                position: absolute;
                top: 0;
                left: 0;
                width: 100%;
                height: 100%;
                margin: 0;
                padding: 0;
                overflow: hidden;
            }

            .sozi-frame-list {
                position: absolute;
                top: 0;
                right: 0;
                width: 33%;
                height: 100%;
                margin: 0;
                padding: 0.5em 1em;
                overflow-y: auto;

                list-style: decimal inside;

                font-family: "Droid Sans", Helvetica, Arial, sans-serif;
                font-size: 12pt;

                color: rgb(240, 255, 255);
                background-color: rgba(34, 34, 34, 0.9);
            }

            .sozi-frame-list li {
                margin: 0;
                padding: 0;
                overflow: hidden;
                white-space: nowrap;
                text-overflow: ellipsis;
            }

            .sozi-frame-list a {
                color: inherit;
                text-decoration: none;
            }

            .sozi-frame-list a:hover {
                color: rgb(0, 204, 255);
                text-decoration: underline;
            }
            
            .sozi-frame-list a.current {
                color: rgb(255, 170, 68);
            }

            .sozi-frame-number {
                position: absolute;
                top: 0;
                left: 1em;
                text-align: center;
                padding: 0.3em 0.6em;

                cursor: pointer;

                font-family: "Droid Sans", Helvetica, Arial, sans-serif;
                font-size: 12pt;
                color: rgb(240, 255, 255);
                background-color: rgba(34, 34, 34, 0.9);
            }

            .sozi-frame-list img {
                position: absolute;
                top: 1em;
                right: 1em;
            }

            #sozi-blank-screen {
                background: black;
                position: absolute;
                top: 0;
                left: 0;
                width: 100%;
                height: 100%;
                opacity: 0;
                visibility: hidden;
                z-index: 999;
                transition: opacity 0.5s, visibility 0.5s;
            }
        </style>
    </head>
    <body>
        <svg xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:cc="http://creativecommons.org/ns#" xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#" xmlns:svg="http://www.w3.org/2000/svg" xmlns="http://www.w3.org/2000/svg" xmlns:sodipodi="http://sodipodi.sourceforge.net/DTD/sodipodi-0.dtd" xmlns:inkscape="http://www.inkscape.org/namespaces/inkscape" width="744.09448819" height="1052.3622047" id="svg2" version="1.1" inkscape:version="0.48.4 r9939" sodipodi:docname="Nytt dokument 1" style="height: auto; width: auto;"><style>svg {
        background: rgba(255, 255, 255, 0.0);
    }</style><defs id="defs4"></defs><sodipodi:namedview id="base" pagecolor="#ffffff" bordercolor="#666666" borderopacity="1.0" inkscape:pageopacity="0.0" inkscape:pageshadow="2" inkscape:zoom="0.35" inkscape:cx="375" inkscape:cy="520" inkscape:document-units="px" inkscape:current-layer="layer1" showgrid="false" inkscape:window-width="1313" inkscape:window-height="744" inkscape:window-x="53" inkscape:window-y="24" inkscape:window-maximized="1"></sodipodi:namedview><metadata id="metadata7">
    <rdf:rdf>
      <cc:work rdf:about="">
        <dc:format>image/svg+xml</dc:format>
        <dc:type rdf:resource="http://purl.org/dc/dcmitype/StillImage"></dc:type>
        <dc:title></dc:title>
      </cc:work>
    </rdf:rdf>
  </metadata><g inkscape:label="Layer 1" inkscape:groupmode="layer" id="layer1">
    <path style="fill:none;stroke:#000000;stroke-width:1px;stroke-linecap:butt;stroke-linejoin:miter;stroke-opacity:1" d="m 142.85714,229.50504 c -26.3807,53.48671 -52.185736,142.09997 -5.71428,188.57143 69.93352,69.93352 121.16201,-85.71429 211.42857,-85.71429 111.9597,0 29.71079,153.99942 151.42857,174.28572 C 600.9951,523.48041 737.8771,402.13074 614.28571,360.93361 455.15798,307.89103 710.05216,711.42339 740,172.36218" id="path2985" inkscape:connector-curvature="0"></path>
  </g></svg>

        <div class="sozi-frame-number" title="Click to show the frame list">1</div>
        <div id="sozi-blank-screen"></div>
        <ol class="sozi-frame-list">
                    
            <a href="#" onClick="sozi.player.openRemoteControl();sozi.player.triggerKey(84, 'keypress');" title="Open remote control">
                <img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABoAAAARCAYAAADDjbwNAAAABHNCSVQICAgIfAhkiAAAAAlwSFlzAAAHiwAAB4sBho2bNAAAABl0RVh0U29mdHdhcmUAd3d3Lmlua3NjYXBlLm9yZ5vuPBoAAABfSURBVDiN7ZUhDoBAEANnyYUXIEDxJX5PzuH4BEkxEAg5WYHYUZuKjtuGJF5UYL7uAHpMhKSxkR/AAKwuUQH2Rl6BxSUB6JxlKUpRilL0U1EBpkZ+f28b8dmjjWePrJyqABBR5yH14QAAAABJRU5ErkJggg==" alt="Remote control"/>
            </a>   
            
                
                    <li value="1"><a data-frame-index="0" href="#frame6019" title="First frame">First frame</a></li>
                
            
                
                    <li value="2"><a data-frame-index="1" href="#frame2957" title="Second frame">Second frame</a></li>
                
            
                
                    <li value="3"><a data-frame-index="2" href="#frame2860" title="Third frame">Third frame</a></li>
                
            
                
                    <li value="4"><a data-frame-index="3" href="#frame3074" title="Fourth frame">Fourth frame</a></li>
                
            
        </ol>
        <script>var soziPresentationData = {"frames":[{"frameId":"frame6019","title":"First frame","timeoutMs":0,"timeoutEnable":false,"transitionDurationMs":1000,"showInFrameList":true,"showFrameNumber":true,"layerProperties":{"layer1":{"transitionTimingFunction":"linear","transitionRelativeZoom":0,"transitionPathId":""},"__sozi_auto__":{"transitionTimingFunction":"linear","transitionRelativeZoom":0,"transitionPathId":""}},"cameraStates":{"layer1":{"cx":154.306587980877,"cy":331.02750211389184,"width":346.3410479746254,"height":259.2976629016376,"opacity":1,"angle":-1.5902773407317586e-15,"clipped":false,"clipXOffset":0,"clipYOffset":0,"clipWidthFactor":1,"clipHeightFactor":1},"__sozi_auto__":{"cx":154.306587980877,"cy":331.02750211389184,"width":346.3410479746254,"height":259.2976629016376,"opacity":1,"angle":-1.5902773407317586e-15,"clipped":false,"clipXOffset":0,"clipYOffset":0,"clipWidthFactor":1,"clipHeightFactor":1}}},{"frameId":"frame2957","title":"Second frame","timeoutMs":0,"timeoutEnable":false,"transitionDurationMs":1000,"showInFrameList":true,"showFrameNumber":true,"layerProperties":{"layer1":{"transitionTimingFunction":"linear","transitionRelativeZoom":0,"transitionPathId":""},"__sozi_auto__":{"transitionTimingFunction":"linear","transitionRelativeZoom":0,"transitionPathId":""}},"cameraStates":{"layer1":{"cx":406.44033670146496,"cy":415.6417295183358,"width":345.73021720218077,"height":259.29766290163747,"opacity":1,"angle":13.851672053506093,"clipped":false,"clipXOffset":0,"clipYOffset":0,"clipWidthFactor":1,"clipHeightFactor":1},"__sozi_auto__":{"cx":406.44033670146496,"cy":415.6417295183358,"width":345.73021720218077,"height":259.29766290163747,"opacity":1,"angle":13.851672053506093,"clipped":false,"clipXOffset":0,"clipYOffset":0,"clipWidthFactor":1,"clipHeightFactor":1}}},{"frameId":"frame2860","title":"Third frame","timeoutMs":0,"timeoutEnable":false,"transitionDurationMs":1000,"showInFrameList":true,"showFrameNumber":true,"layerProperties":{"layer1":{"transitionTimingFunction":"linear","transitionRelativeZoom":0,"transitionPathId":""},"__sozi_auto__":{"transitionTimingFunction":"linear","transitionRelativeZoom":0,"transitionPathId":""}},"cameraStates":{"layer1":{"cx":615.9297651127611,"cy":402.3710373638981,"width":346.34104797462544,"height":259.2976629016376,"opacity":1,"angle":-1.5902773407317586e-15,"clipped":false,"clipXOffset":0,"clipYOffset":0,"clipWidthFactor":1,"clipHeightFactor":1},"__sozi_auto__":{"cx":615.9297651127611,"cy":402.3710373638981,"width":346.34104797462544,"height":259.2976629016376,"opacity":1,"angle":-1.5902773407317586e-15,"clipped":false,"clipXOffset":0,"clipYOffset":0,"clipWidthFactor":1,"clipHeightFactor":1}}},{"frameId":"frame3074","title":"Fourth frame","timeoutMs":0,"timeoutEnable":false,"transitionDurationMs":1000,"showInFrameList":true,"showFrameNumber":true,"layerProperties":{"layer1":{"transitionTimingFunction":"linear","transitionRelativeZoom":0,"transitionPathId":""},"__sozi_auto__":{"transitionTimingFunction":"linear","transitionRelativeZoom":0,"transitionPathId":""}},"cameraStates":{"layer1":{"cx":620.5109959060776,"cy":419.7797143784955,"width":345.73021720218077,"height":259.29766290163747,"opacity":1,"angle":-86.3438347117891,"clipped":false,"clipXOffset":0,"clipYOffset":0,"clipWidthFactor":1,"clipHeightFactor":1},"__sozi_auto__":{"cx":620.5109959060776,"cy":419.7797143784955,"width":345.73021720218077,"height":259.29766290163747,"opacity":1,"angle":-86.3438347117891,"clipped":false,"clipXOffset":0,"clipYOffset":0,"clipWidthFactor":1,"clipHeightFactor":1}}}],"elementsToHide":[]};</script>

        <script>(function e(t, n, r) {
    function s(o, u) {
        if (!n[o]) {
            if (!t[o]) {
                var a = typeof require == "function" && require;
                if (!u && a) return a(o, !0);
                if (i) return i(o, !0);
                var f = new Error("Cannot find module '" + o + "'");
                throw f.code = "MODULE_NOT_FOUND", f;
            }
            var l = n[o] = {
                exports: {}
            };
            t[o][0].call(l.exports, function(e) {
                var n = t[o][1][e];
                return s(n ? n : e);
            }, l, l.exports, e, t, n, r);
        }
        return n[o].exports;
    }
    var i = typeof require == "function" && require;
    for (var o = 0; o < r.length; o++) s(r[o]);
    return s;
})({
    1: [ function(require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: true
        });
        function copyIfSet(dest, src, prop) {
            if (src.hasOwnProperty(prop)) {
                dest[prop] = src[prop];
            }
        }
        var CameraState = {
            opacity: 1,
            angle: 0,
            clipped: false,
            clipXOffset: 0,
            clipYOffset: 0,
            clipWidthFactor: 1,
            clipHeightFactor: 1,
            init: function(svgRoot) {
                this.svgRoot = svgRoot;
                var initialBBox = svgRoot.getBBox();
                this.cx = initialBBox.x + initialBBox.width / 2;
                this.cy = initialBBox.y + initialBBox.height / 2;
                this.width = initialBBox.width;
                this.height = initialBBox.height;
                return this;
            },
            initFrom: function(state) {
                this.svgRoot = state.svgRoot;
                this.cx = state.cx;
                this.cy = state.cy;
                this.width = state.width;
                this.height = state.height;
                this.opacity = state.opacity;
                this.angle = state.angle;
                this.clipped = state.clipped;
                this.clipXOffset = state.clipXOffset;
                this.clipYOffset = state.clipYOffset;
                this.clipWidthFactor = state.clipWidthFactor;
                this.clipHeightFactor = state.clipHeightFactor;
                return this;
            },
            toStorable: function() {
                return {
                    cx: this.cx,
                    cy: this.cy,
                    width: this.width,
                    height: this.height,
                    opacity: this.opacity,
                    angle: this.angle,
                    clipped: this.clipped,
                    clipXOffset: this.clipXOffset,
                    clipYOffset: this.clipYOffset,
                    clipWidthFactor: this.clipWidthFactor,
                    clipHeightFactor: this.clipHeightFactor
                };
            },
            toMinimalStorable: function() {
                return this.toStorable();
            },
            fromStorable: function(storable) {
                copyIfSet(this, storable, "cx");
                copyIfSet(this, storable, "cy");
                copyIfSet(this, storable, "width");
                copyIfSet(this, storable, "height");
                copyIfSet(this, storable, "opacity");
                copyIfSet(this, storable, "angle");
                copyIfSet(this, storable, "clipped");
                copyIfSet(this, storable, "clipXOffset");
                copyIfSet(this, storable, "clipYOffset");
                copyIfSet(this, storable, "clipWidthFactor");
                copyIfSet(this, storable, "clipHeightFactor");
                return this;
            },
            setAngle: function(angle) {
                this.angle = (angle + 180) % 360 - 180;
                return this;
            },
            setAtElement: function(svgElement, deltaX, deltaY, widthFactor, heightFactor, deltaAngle) {
                deltaX = deltaX || 0;
                deltaY = deltaY || 0;
                widthFactor = widthFactor || 1;
                heightFactor = heightFactor || 1;
                deltaAngle = deltaAngle || 0;
                var b = svgElement.getBBox();
                var c = this.svgRoot.createSVGPoint();
                c.x = b.x + b.width / 2;
                c.y = b.y + b.height / 2;
                var layerGroup = svgElement;
                while (layerGroup.parentNode.parentNode !== this.svgRoot) {
                    layerGroup = layerGroup.parentNode;
                }
                var matrix = layerGroup.getCTM().inverse().multiply(svgElement.getCTM());
                c = c.matrixTransform(matrix);
                var scale = Math.sqrt(matrix.a * matrix.a + matrix.b * matrix.b);
                this.cx = c.x + deltaX;
                this.cy = c.y + deltaY;
                this.width = b.width * scale * widthFactor;
                this.height = b.height * scale * heightFactor;
                this.angle = Math.atan2(matrix.b, matrix.a) * 180 / Math.PI + deltaAngle;
                return this;
            },
            offsetFromElement: function(svgElement) {
                var cam = Object.create(CameraState).init(this.svgRoot).setAtElement(svgElement);
                return {
                    deltaX: this.cx - cam.cx,
                    deltaY: this.cy - cam.cy,
                    widthFactor: this.width / cam.width,
                    heightFactor: this.height / cam.height,
                    deltaAngle: this.angle - cam.angle
                };
            }
        };
        exports.CameraState = CameraState;
    }, {} ],
    2: [ function(require, module, exports) {
        Object.defineProperty(exports, "__esModule", {
            value: true
        });
        var _utils = require("../utils");
        var _CameraState = require("./CameraState");
        "use strict";
        function copyIfSet(dest, src, prop) {
            if (src.hasOwnProperty(prop)) {
                dest[prop] = src[prop];
            }
        }
        var LayerProperties = {
            link: false,
            referenceElementId: "",
            referenceElementAuto: true,
            transitionTimingFunction: "linear",
            transitionRelativeZoom: 0,
            transitionPathId: "",
            init: function(frame) {
                this.frame = frame;
                return this;
            },
            initFrom: function(other) {
                this.frame = other.frame;
                this.link = other.link;
                this.referenceElementId = other.referenceElementId;
                this.referenceElementAuto = other.referenceElementAuto;
                this.transitionTimingFunction = other.transitionTimingFunction;
                this.transitionRelativeZoom = other.transitionRelativeZoom;
                this.transitionPathId = other.transitionPathId;
                return this;
            },
            toStorable: function() {
                return {
                    link: this.link,
                    referenceElementId: this.referenceElementId,
                    referenceElementAuto: this.referenceElementAuto,
                    transitionTimingFunction: this.transitionTimingFunction,
                    transitionRelativeZoom: this.transitionRelativeZoom,
                    transitionPathId: this.transitionPathId
                };
            },
            toMinimalStorable: function() {
                return {
                    transitionTimingFunction: this.transitionTimingFunction,
                    transitionRelativeZoom: this.transitionRelativeZoom,
                    transitionPathId: this.transitionPathId
                };
            },
            fromStorable: function(storable) {
                copyIfSet(this, storable, "link");
                copyIfSet(this, storable, "referenceElementId");
                copyIfSet(this, storable, "referenceElementAuto");
                copyIfSet(this, storable, "transitionTimingFunction");
                copyIfSet(this, storable, "transitionRelativeZoom");
                copyIfSet(this, storable, "transitionPathId");
                return this;
            },
            get index() {
                return this.frame.layerProperties.indexOf(this);
            },
            get referenceElement() {
                return this.frame.presentation.document.root.getElementById(this.referenceElementId);
            },
            get transitionPath() {
                return this.frame.presentation.document.root.getElementById(this.transitionPathId);
            },
            get referenceElementHide() {
                return this.frame.presentation.elementsToHide.indexOf(this.referenceElementId) >= 0;
            },
            set referenceElementHide(hide) {
                var hidden = this.referenceElementHide;
                if (hide && !hidden) {
                    this.frame.presentation.elementsToHide.push(this.referenceElementId);
                } else if (!hide && hidden) {
                    var index = this.frame.presentation.elementsToHide.indexOf(this.referenceElementId);
                    this.frame.presentation.elementsToHide.splice(index, 1);
                }
                if (this.referenceElement) {
                    this.referenceElement.style.visibility = hide ? "hidden" : "visible";
                }
            },
            get transitionPathHide() {
                return this.frame.presentation.elementsToHide.indexOf(this.transitionPathId) >= 0;
            },
            set transitionPathHide(hide) {
                var hidden = this.transitionPathHide;
                if (hide && !hidden) {
                    this.frame.presentation.elementsToHide.push(this.transitionPathId);
                } else if (!hide && hidden) {
                    var index = this.frame.presentation.elementsToHide.indexOf(this.transitionPathId);
                    this.frame.presentation.elementsToHide.splice(index, 1);
                }
                if (this.transitionPath) {
                    this.transitionPath.style.visibility = hide ? "hidden" : "visible";
                }
            }
        };
        exports.LayerProperties = LayerProperties;
        var Frame = {
            title: "New frame",
            timeoutMs: 0,
            timeoutEnable: false,
            transitionDurationMs: 1e3,
            showInFrameList: true,
            showFrameNumber: true,
            init: function(presentation) {
                var _this = this;
                this.presentation = presentation;
                this.frameId = presentation.makeFrameId();
                this.layerProperties = presentation.layers.map(function(lp) {
                    return Object.create(LayerProperties).init(_this);
                });
                this.cameraStates = presentation.layers.map(function(cs) {
                    return Object.create(_CameraState.CameraState).init(presentation.document.root);
                });
                return this;
            },
            initFrom: function(other, preserveId) {
                this.presentation = other.presentation;
                if (!preserveId) {
                    this.frameId = other.presentation.makeFrameId();
                }
                this.title = other.title;
                this.timeoutMs = other.timeoutMs;
                this.timeoutEnable = other.timeoutEnable;
                this.transitionDurationMs = other.transitionDurationMs;
                this.showInFrameList = other.showInFrameList;
                this.showFrameNumber = other.showFrameNumber;
                this.layerProperties = other.layerProperties.map(function(lp) {
                    return Object.create(LayerProperties).initFrom(lp);
                });
                this.cameraStates = other.cameraStates.map(function(cs) {
                    return Object.create(_CameraState.CameraState).initFrom(cs);
                });
                return this;
            },
            toStorable: function() {
                var _this2 = this;
                var layerProperties = {};
                var cameraStates = {};
                var cameraOffsets = {};
                this.presentation.layers.forEach(function(layer, index) {
                    var lp = _this2.layerProperties[index];
                    var cs = _this2.cameraStates[index];
                    var re = lp.referenceElement;
                    var key = layer.groupId;
                    layerProperties[key] = lp.toStorable();
                    cameraStates[key] = cs.toStorable();
                    if (re) {
                        cameraOffsets[key] = _this2.cameraStates[index].offsetFromElement(re);
                    }
                });
                return {
                    frameId: this.frameId,
                    title: this.title,
                    timeoutMs: this.timeoutMs,
                    timeoutEnable: this.timeoutEnable,
                    transitionDurationMs: this.transitionDurationMs,
                    showInFrameList: this.showInFrameList,
                    showFrameNumber: this.showFrameNumber,
                    layerProperties: layerProperties,
                    cameraStates: cameraStates,
                    cameraOffsets: cameraOffsets
                };
            },
            toMinimalStorable: function() {
                var _this3 = this;
                var layerProperties = {};
                var cameraStates = {};
                this.presentation.layers.forEach(function(layer, index) {
                    var lp = _this3.layerProperties[index];
                    var cs = _this3.cameraStates[index];
                    var key = layer.groupId;
                    layerProperties[key] = lp.toMinimalStorable();
                    cameraStates[key] = cs.toMinimalStorable();
                });
                return {
                    frameId: this.frameId,
                    title: this.title,
                    timeoutMs: this.timeoutMs,
                    timeoutEnable: this.timeoutEnable,
                    transitionDurationMs: this.transitionDurationMs,
                    showInFrameList: this.showInFrameList,
                    showFrameNumber: this.showFrameNumber,
                    layerProperties: layerProperties,
                    cameraStates: cameraStates
                };
            },
            fromStorable: function(storable) {
                var _this4 = this;
                copyIfSet(this, storable, "frameId");
                copyIfSet(this, storable, "title");
                copyIfSet(this, storable, "timeoutMs");
                copyIfSet(this, storable, "timeoutEnable");
                copyIfSet(this, storable, "transitionDurationMs");
                copyIfSet(this, storable, "showInFrameList");
                copyIfSet(this, storable, "showFrameNumber");
                this.presentation.layers.forEach(function(layer, index) {
                    var key = layer.groupId;
                    if (key in storable.layerProperties) {
                        var lp = _this4.layerProperties[index];
                        lp.fromStorable(storable.layerProperties[key]);
                        var cs = _this4.cameraStates[index].fromStorable(storable.cameraStates[key]);
                        var re = lp.referenceElement;
                        if (re) {
                            var ofs = storable.cameraOffsets[key] || {};
                            cs.setAtElement(re, ofs.deltaX, ofs.deltaY, ofs.widthFactor, ofs.heightFactor, ofs.deltaAngle);
                        }
                    }
                });
                return this;
            },
            get index() {
                return this.presentation.frames.indexOf(this);
            },
            setAtStates: function(states) {
                var _this5 = this;
                states.forEach(function(state, index) {
                    _this5.cameraStates[index].initFrom(state);
                });
            }
        };
        exports.Frame = Frame;
        var Layer = {
            init: function(presentation, label, auto) {
                this.presentation = presentation;
                this.label = label;
                this.auto = auto;
                this.svgNodes = [];
                return this;
            },
            get groupId() {
                return this.auto ? "__sozi_auto__" : this.svgNodes[0].getAttribute("id");
            },
            get index() {
                return this.presentation.layers.indexOf(this);
            },
            get isVisible() {
                return this.svgNodes.some(function(node) {
                    return window.getComputedStyle(node).display !== "none";
                });
            },
            set isVisible(visible) {
                this.svgNodes.forEach(function(node) {
                    node.style.display = visible ? "inline" : "none";
                });
            }
        };
        exports.Layer = Layer;
        var SVG_NS = "http://www.w3.org/2000/svg";
        var Presentation = {
            aspectWidth: 4,
            aspectHeight: 3,
            init: function(svgDocument) {
                var _this6 = this;
                this.document = svgDocument;
                this.frames = [];
                this.layers = [];
                this.elementsToHide = [];
                var autoLayer = Object.create(Layer).init(this, "auto", true);
                (0, _utils.toArray)(this.document.root.childNodes).forEach(function(svgNode) {
                    if (svgNode.localName === "g") {
                        var nodeId = svgNode.getAttribute("id");
                        if (nodeId === null) {
                            autoLayer.svgNodes.push(svgNode);
                        } else {
                            var layer = Object.create(Layer).init(_this6, _this6.document.handler.getLabel(svgNode) || "#" + nodeId, false);
                            layer.svgNodes.push(svgNode);
                            _this6.layers.push(layer);
                        }
                    }
                });
                this.layers.push(autoLayer);
                return this;
            },
            toStorable: function() {
                return {
                    aspectWidth: this.aspectWidth,
                    aspectHeight: this.aspectHeight,
                    frames: this.frames.map(function(frame) {
                        return frame.toStorable();
                    }),
                    elementsToHide: this.elementsToHide.slice()
                };
            },
            toMinimalStorable: function() {
                return {
                    frames: this.frames.map(function(frame) {
                        return frame.toMinimalStorable();
                    }),
                    elementsToHide: this.elementsToHide.slice()
                };
            },
            fromStorable: function(storable) {
                var _this7 = this;
                copyIfSet(this, storable, "aspectWidth");
                copyIfSet(this, storable, "aspectHeight");
                this.frames = storable.frames.map(function(f) {
                    return Object.create(Frame).init(_this7).fromStorable(f);
                });
                if (storable.elementsToHide) {
                    this.elementsToHide = storable.elementsToHide.slice();
                }
                return this;
            },
            get title() {
                var svgTitles = this.document.root.getElementsByTagNameNS(SVG_NS, "title");
                return svgTitles.length ? svgTitles[0].firstChild.wholeText.trim() : "Untitled";
            },
            makeFrameId: function() {
                var prefix = "frame";
                var suffix = Math.floor(1e3 * (1 + 9 * Math.random()));
                var frameId;
                do {
                    frameId = prefix + suffix;
                    suffix++;
                } while (this.frames.some(function(frame) {
                    return frame.frameId === frameId;
                }));
                return frameId;
            },
            getFrameWithId: function(frameId) {
                for (var i = 0; i < this.frames.length; i++) {
                    if (this.frames[i].frameId === frameId) {
                        return this.frames[i];
                    }
                }
                return null;
            },
            getLayerWithId: function(groupId) {
                for (var i = 0; i < this.layers.length; i++) {
                    if (this.layers[i].groupId === groupId) {
                        return this.layers[i];
                    }
                }
                return null;
            },
            updateLinkedLayers: function() {
                var _this8 = this;
                if (!this.frames.length) {
                    return;
                }
                var firstCameraStates = this.frames[0].cameraStates;
                var defaultCameraState = firstCameraStates[firstCameraStates.length - 1];
                this.layers.forEach(function(layer, layerIndex) {
                    var cameraState = defaultCameraState;
                    _this8.frames.forEach(function(frame) {
                        if (frame.layerProperties[layerIndex].link) {
                            frame.cameraStates[layerIndex].initFrom(cameraState);
                        } else {
                            cameraState = frame.cameraStates[layerIndex];
                        }
                    });
                });
            }
        };
        exports.Presentation = Presentation;
    }, {
        "../utils": 14,
        "./CameraState": 1
    } ],
    3: [ function(require, module, exports) {
        function _interopRequireWildcard(obj) {
            if (obj && obj.__esModule) {
                return obj;
            } else {
                var newObj = {};
                if (obj != null) {
                    for (var key in obj) {
                        if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key];
                    }
                }
                newObj["default"] = obj;
                return newObj;
            }
        }
        var _svgSVGDocument = require("./svg/SVGDocument");
        var _modelPresentation = require("./model/Presentation");
        var _playerViewport = require("./player/Viewport");
        var _playerPlayer = require("./player/Player");
        var _playerMedia = require("./player/Media");
        var Media = _interopRequireWildcard(_playerMedia);
        var _playerFrameList = require("./player/FrameList");
        var FrameList = _interopRequireWildcard(_playerFrameList);
        var _playerFrameNumber = require("./player/FrameNumber");
        var FrameNumber = _interopRequireWildcard(_playerFrameNumber);
        var _playerFrameURL = require("./player/FrameURL");
        var FrameURL = _interopRequireWildcard(_playerFrameURL);
        "use strict";
        window.addEventListener("load", function() {
            _svgSVGDocument.SVGDocument.init(document.querySelector("svg"));
            _modelPresentation.Presentation.init(_svgSVGDocument.SVGDocument);
            _playerViewport.Viewport.init(_modelPresentation.Presentation, false).onLoad();
            _modelPresentation.Presentation.fromStorable(window.soziPresentationData);
            _playerPlayer.Player.init(_playerViewport.Viewport, _modelPresentation.Presentation);
            Media.init(_playerPlayer.Player);
            FrameList.init(_playerPlayer.Player);
            FrameNumber.init(_playerPlayer.Player);
            FrameURL.init(_playerPlayer.Player);
            window.sozi = {
                presentation: _modelPresentation.Presentation,
                viewport: _playerViewport.Viewport,
                player: _playerPlayer.Player
            };
            _playerPlayer.Player.addListener("change:playing", function(player, playing) {
                if (playing) {
                    document.title = _modelPresentation.Presentation.title;
                } else {
                    document.title = _modelPresentation.Presentation.title + "(Paused)";
                }
            });
            window.addEventListener("resize", _playerViewport.Viewport.repaint.bind(_playerViewport.Viewport));
            if (_modelPresentation.Presentation.frames.length) {
                _playerPlayer.Player.playFromIndex(0);
            }
            _playerViewport.Viewport.repaint();
        });
    }, {
        "./model/Presentation": 2,
        "./player/FrameList": 6,
        "./player/FrameNumber": 7,
        "./player/FrameURL": 8,
        "./player/Media": 9,
        "./player/Player": 10,
        "./player/Viewport": 12,
        "./svg/SVGDocument": 13
    } ],
    4: [ function(require, module, exports) {
        Object.defineProperty(exports, "__esModule", {
            value: true
        });
        var _events = require("events");
        "use strict";
        var requestAnimationFrame = window.requestAnimationFrame || window.mozRequestAnimationFrame || window.webkitRequestAnimationFrame || window.msRequestAnimationFrame || window.oRequestAnimationFrame;
        var perf = window.performance && window.performance.now ? window.performance : Date;
        var TIME_STEP_MS = 40;
        var timer;
        var runningAnimators = 0;
        var animatorList = [];
        function loop() {
            if (runningAnimators > 0) {
                if (requestAnimationFrame) {
                    requestAnimationFrame(loop);
                }
                animatorList.forEach(function(animator) {
                    if (animator.running) {
                        animator.step();
                    }
                });
            } else if (!requestAnimationFrame) {
                window.clearInterval(timer);
            }
        }
        function start() {
            if (requestAnimationFrame) {
                requestAnimationFrame(loop);
            } else {
                timer = window.setInterval(loop, TIME_STEP_MS);
            }
        }
        var Animator = Object.create(_events.EventEmitter.prototype);
        exports.Animator = Animator;
        Animator.init = function() {
            _events.EventEmitter.call(this);
            this.durationMs = 500;
            this.initialTime = 0;
            this.running = false;
            animatorList.push(this);
            return this;
        };
        Animator.start = function(durationMs) {
            this.durationMs = durationMs;
            this.initialTime = perf.now();
            this.emit("step", 0);
            if (!this.running) {
                this.running = true;
                runningAnimators++;
                if (runningAnimators === 1) {
                    start();
                }
            }
        };
        Animator.stop = function() {
            if (this.running) {
                this.running = false;
                runningAnimators--;
                this.emit("stop");
            }
        };
        Animator.step = function() {
            var elapsedTime = perf.now() - this.initialTime;
            if (elapsedTime >= this.durationMs) {
                this.emit("step", 1);
                this.running = false;
                runningAnimators--;
                this.emit("done");
            } else {
                this.emit("step", elapsedTime / this.durationMs);
            }
        };
    }, {
        events: 15
    } ],
    5: [ function(require, module, exports) {
        Object.defineProperty(exports, "__esModule", {
            value: true
        });
        var _modelCameraState = require("../model/CameraState");
        "use strict";
        var SVG_NS = "http://www.w3.org/2000/svg";
        var Camera = Object.create(_modelCameraState.CameraState);
        exports.Camera = Camera;
        Camera.init = function(viewport, layer) {
            _modelCameraState.CameraState.init.call(this, viewport.svgRoot);
            this.viewport = viewport;
            this.layer = layer;
            this.selected = true;
            this.svgClipRect = document.createElementNS(SVG_NS, "rect");
            if (viewport.editMode) {
                this.maskValue = 0;
                var svgMask = document.createElementNS(SVG_NS, "mask");
                var svgMaskId = viewport.makeUniqueId("sozi-mask-");
                svgMask.setAttribute("id", svgMaskId);
                viewport.svgRoot.appendChild(svgMask);
                this.svgMaskRect = document.createElementNS(SVG_NS, "rect");
                svgMask.appendChild(this.svgMaskRect);
                this.svgClipRect.setAttribute("fill", "white");
                svgMask.appendChild(this.svgClipRect);
                this.svgClipOutlineRect1 = document.createElementNS(SVG_NS, "rect");
                this.svgClipOutlineRect1.setAttribute("stroke", "black");
                this.svgClipOutlineRect1.setAttribute("fill", "none");
                viewport.svgRoot.appendChild(this.svgClipOutlineRect1);
                this.svgClipOutlineRect2 = document.createElementNS(SVG_NS, "rect");
                this.svgClipOutlineRect2.setAttribute("stroke", "white");
                this.svgClipOutlineRect2.setAttribute("fill", "none");
                this.svgClipOutlineRect2.setAttribute("stroke-dasharray", "2,2");
                viewport.svgRoot.appendChild(this.svgClipOutlineRect2);
                this.concealClipping();
            } else {
                var svgClipPath = document.createElementNS(SVG_NS, "clipPath");
                var svgClipPathId = viewport.makeUniqueId("sozi-clip-path-");
                svgClipPath.setAttribute("id", svgClipPathId);
                svgClipPath.appendChild(this.svgClipRect);
                viewport.svgRoot.appendChild(svgClipPath);
            }
            this.svgTransformGroups = layer.svgNodes.map(function(svgNode) {
                var svgClippedGroup = document.createElementNS(SVG_NS, "g");
                viewport.svgRoot.insertBefore(svgClippedGroup, svgNode);
                if (viewport.editMode) {
                    svgClippedGroup.setAttribute("mask", "url(#" + svgMaskId + ")");
                } else {
                    svgClippedGroup.setAttribute("clip-path", "url(#" + svgClipPathId + ")");
                }
                var svgGroup = document.createElementNS(SVG_NS, "g");
                svgGroup.appendChild(svgNode);
                svgClippedGroup.appendChild(svgGroup);
                return svgGroup;
            });
            return this;
        };
        Camera.revealClipping = function() {
            this.maskValue = 64;
            this.svgClipOutlineRect1.style.display = "inline";
            this.svgClipOutlineRect2.style.display = "inline";
        };
        Camera.concealClipping = function() {
            this.maskValue = 0;
            this.svgClipOutlineRect1.style.display = "none";
            this.svgClipOutlineRect2.style.display = "none";
        };
        Object.defineProperty(Camera, "scale", {
            get: function() {
                return Math.min(this.viewport.width / this.width, this.viewport.height / this.height);
            }
        });
        Camera.rotate = function(angle) {
            this.restoreAspectRatio();
            return this.setAngle(this.angle + angle).update();
        };
        Camera.zoom = function(factor, x, y) {
            this.width /= factor;
            this.height /= factor;
            this.restoreAspectRatio();
            return this.translate((1 - factor) * (x - this.viewport.width / 2), (1 - factor) * (y - this.viewport.height / 2));
        };
        Camera.translate = function(deltaX, deltaY) {
            var scale = this.scale;
            var angleRad = this.angle * Math.PI / 180;
            var si = Math.sin(angleRad);
            var co = Math.cos(angleRad);
            this.cx -= (deltaX * co - deltaY * si) / scale;
            this.cy -= (deltaX * si + deltaY * co) / scale;
            this.restoreAspectRatio();
            return this.update();
        };
        Camera.clip = function(x0, y0, x1, y1) {
            this.clipped = true;
            var scale = this.scale;
            var clipWidth = Math.abs(x1 - x0) + 1;
            var clipHeight = Math.abs(y1 - y0) + 1;
            this.clipXOffset = (Math.min(x0, x1) - (this.viewport.width - clipWidth) / 2) * this.width / clipWidth;
            this.clipYOffset = (Math.min(y0, y1) - (this.viewport.height - clipHeight) / 2) * this.height / clipHeight;
            this.clipWidthFactor = clipWidth / this.width / scale;
            this.clipHeightFactor = clipHeight / this.height / scale;
            return this.update();
        };
        Camera.restoreAspectRatio = function() {
            var viewportRatio = this.viewport.width / this.viewport.height;
            var camRatio = this.width / this.height;
            var ratio = viewportRatio / camRatio;
            if (ratio > 1) {
                this.width *= ratio;
                if (this.clipped) {
                    this.clipWidthFactor /= ratio;
                }
            } else {
                this.height /= ratio;
                if (this.clipped) {
                    this.clipHeightFactor *= ratio;
                }
            }
        };
        Camera.getCandidateReferenceElement = function() {
            if (!this.svgRoot.getIntersectionList) {
                return this.svgRoot;
            }
            var viewportRect = this.svgRoot.createSVGRect();
            viewportRect.x = 0;
            viewportRect.y = 0;
            viewportRect.width = this.viewport.width;
            viewportRect.height = this.viewport.height;
            var viewportArea = this.viewport.width * this.viewport.height;
            var intersectionList = this.svgRoot.getIntersectionList(viewportRect, this.layer.svgNodes[0]);
            var bestScore = -1;
            var result;
            for (var i = 0; i < intersectionList.length; i++) {
                var elt = intersectionList[i];
                if (elt.hasAttribute("id")) {
                    var eltRect = elt.getBoundingClientRect();
                    var eltArea = eltRect.width * eltRect.height;
                    var l = Math.max(eltRect.left, this.viewport.x);
                    var t = Math.max(eltRect.top, this.viewport.y);
                    var r = Math.min(eltRect.right, this.viewport.x + this.viewport.width);
                    var b = Math.min(eltRect.bottom, this.viewport.y + this.viewport.height);
                    var intersectArea = (r - l) * (b - t);
                    var eltScore = viewportArea + eltArea - 2 * intersectArea;
                    if (bestScore < 0 || eltScore < bestScore) {
                        bestScore = eltScore;
                        result = elt;
                    }
                }
            }
            return result;
        };
        Object.defineProperty(Camera, "clipRect", {
            get: function() {
                var width, height, x, y;
                if (this.clipped) {
                    var scale = this.scale;
                    width = Math.round(this.width * this.clipWidthFactor * scale);
                    height = Math.round(this.height * this.clipHeightFactor * scale);
                    x = Math.round((this.viewport.width - width) / 2 + this.clipXOffset * this.clipWidthFactor * scale);
                    y = Math.round((this.viewport.height - height) / 2 + this.clipYOffset * this.clipHeightFactor * scale);
                } else {
                    width = this.viewport.width;
                    height = this.viewport.height;
                    x = 0;
                    y = 0;
                }
                return {
                    width: width,
                    height: height,
                    x: x,
                    y: y
                };
            }
        });
        Camera.update = function() {
            var _this = this;
            var rect = this.clipRect;
            this.svgClipRect.setAttribute("x", rect.x);
            this.svgClipRect.setAttribute("y", rect.y);
            this.svgClipRect.setAttribute("width", rect.width);
            this.svgClipRect.setAttribute("height", rect.height);
            if (this.viewport.editMode) {
                this.svgMaskRect.setAttribute("fill", "rgb(" + this.maskValue + "," + this.maskValue + "," + this.maskValue + ")");
                this.svgMaskRect.setAttribute("x", 0);
                this.svgMaskRect.setAttribute("y", 0);
                this.svgMaskRect.setAttribute("width", this.viewport.width);
                this.svgMaskRect.setAttribute("height", this.viewport.height);
                this.svgClipOutlineRect1.setAttribute("x", rect.x);
                this.svgClipOutlineRect1.setAttribute("y", rect.y);
                this.svgClipOutlineRect1.setAttribute("width", rect.width);
                this.svgClipOutlineRect1.setAttribute("height", rect.height);
                this.svgClipOutlineRect2.setAttribute("x", rect.x);
                this.svgClipOutlineRect2.setAttribute("y", rect.y);
                this.svgClipOutlineRect2.setAttribute("width", rect.width);
                this.svgClipOutlineRect2.setAttribute("height", rect.height);
            }
            var scale = this.scale;
            var translateX = this.viewport.width / scale / 2 - this.cx;
            var translateY = this.viewport.height / scale / 2 - this.cy;
            this.svgTransformGroups.forEach(function(svgGroup) {
                svgGroup.setAttribute("transform", "scale(" + scale + ")" + "translate(" + translateX + "," + translateY + ")" + "rotate(" + -_this.angle + "," + _this.cx + "," + _this.cy + ")");
                svgGroup.setAttribute("opacity", _this.opacity);
            });
            return this;
        };
        Camera.interpolate = function(initialState, finalState, progress, timingFunction, relativeZoom, svgPath, reversePath) {
            var tfProgress = timingFunction(progress);
            var tfRemaining = 1 - tfProgress;
            function linear(initial, final) {
                return final * tfProgress + initial * tfRemaining;
            }
            function quadratic(u0, u1) {
                var um = (relativeZoom > 0 ? Math.max(u0, u1) : Math.min(u0, u1)) * (1 + relativeZoom);
                var du0 = u0 - um;
                var du1 = u1 - um;
                var r = Math.sqrt(du0 / du1);
                var tm = r / (1 + r);
                var k = du0 / tm / tm;
                var dt = progress - tm;
                return k * dt * dt + um;
            }
            if (relativeZoom) {
                this.width = quadratic(initialState.width, finalState.width);
                this.height = quadratic(initialState.height, finalState.height);
            } else {
                this.width = linear(initialState.width, finalState.width);
                this.height = linear(initialState.height, finalState.height);
            }
            if (svgPath) {
                var pathLength = svgPath.getTotalLength();
                var startPoint = svgPath.getPointAtLength(reversePath ? pathLength : 0);
                var endPoint = svgPath.getPointAtLength(reversePath ? 0 : pathLength);
                var currentPoint = svgPath.getPointAtLength(pathLength * (reversePath ? tfRemaining : tfProgress));
                this.cx = currentPoint.x + linear(initialState.cx - startPoint.x, finalState.cx - endPoint.x);
                this.cy = currentPoint.y + linear(initialState.cy - startPoint.y, finalState.cy - endPoint.y);
            } else {
                this.cx = linear(initialState.cx, finalState.cx);
                this.cy = linear(initialState.cy, finalState.cy);
            }
            this.opacity = linear(initialState.opacity, finalState.opacity);
            if (finalState.angle - initialState.angle > 180) {
                this.angle = linear(initialState.angle, finalState.angle - 360);
            } else if (finalState.angle - initialState.angle < -180) {
                this.angle = linear(initialState.angle - 360, finalState.angle);
            } else {
                this.angle = linear(initialState.angle, finalState.angle);
            }
            this.clipped = true;
            var scale = this.scale;
            var clipDefaults = {
                clipXOffset: 0,
                clipYOffset: 0,
                clipWidthFactor: this.viewport.width / this.width / scale,
                clipHeightFactor: this.viewport.height / this.height / scale
            };
            var initialClipping = initialState.clipped ? initialState : clipDefaults;
            var finalClipping = finalState.clipped ? finalState : clipDefaults;
            for (var clipProp in clipDefaults) {
                this[clipProp] = linear(initialClipping[clipProp], finalClipping[clipProp]);
            }
        };
    }, {
        "../model/CameraState": 1
    } ],
    6: [ function(require, module, exports) {
        Object.defineProperty(exports, "__esModule", {
            value: true
        });
        exports.init = init;
        exports.open = open;
        exports.close = close;
        exports.toggle = toggle;
        function _interopRequireWildcard(obj) {
            if (obj && obj.__esModule) {
                return obj;
            } else {
                var newObj = {};
                if (obj != null) {
                    for (var key in obj) {
                        if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key];
                    }
                }
                newObj["default"] = obj;
                return newObj;
            }
        }
        var _utils = require("../utils");
        var _Animator = require("./Animator");
        var _Timing = require("./Timing");
        var Timing = _interopRequireWildcard(_Timing);
        "use strict";
        const DURATION_MS = 500;
        var frameList;
        var links;
        var player;
        var animator;
        var isOpen = false;
        var startOffset = -1;
        var endOffset = -1;
        var currentOffset = startOffset;
        function init(aPlayer) {
            player = aPlayer;
            frameList = document.querySelector(".sozi-frame-list");
            links = (0, _utils.toArray)(frameList.querySelectorAll("li a"));
            links.forEach(function(link) {
                link.addEventListener("click", function(evt) {
                    if (evt.button === 0) {
                        player.previewFrame(parseInt(link.dataset.frameIndex));
                        evt.preventDefault();
                    }
                });
            });
            animator = Object.create(_Animator.Animator).init();
            animator.addListener("step", onAnimatorStep);
            window.addEventListener("keypress", onKeyPress, false);
            player.viewport.addListener("mouseDown", onMouseDown);
            frameList.addEventListener("mouseout", onMouseOut, false);
            aPlayer.addListener("frameChange", onFrameChange);
            setCurrentOffset(startOffset);
        }
        function setCurrentOffset(offset) {
            currentOffset = offset;
            frameList.style.left = currentOffset * frameList.clientWidth + "px";
        }
        function moveTo(offset) {
            player.pause();
            startOffset = currentOffset;
            endOffset = offset;
            animator.start(Math.abs(endOffset - startOffset) * DURATION_MS);
        }
        function open() {
            moveTo(0);
        }
        function close() {
            moveTo(-1);
        }
        function toggle() {
            moveTo(-1 - endOffset);
        }
        function onKeyPress(evt) {
            if (evt.altKey || evt.ctrlKey || evt.metaKey) {
                return;
            }
            switch (evt.charCode || evt.which) {
              case 84:
              case 116:
                toggle();
                break;

              default:
                return;
            }
            evt.stopPropagation();
            evt.preventDefault();
        }
        function onAnimatorStep(progress) {
            var p = Timing.ease(progress);
            setCurrentOffset(endOffset * p + startOffset * (1 - p));
        }
        function onMouseDown(button) {
            if (button === 1) {
                toggle();
            }
        }
        function onMouseOut(evt) {
            var rel = evt.relatedTarget;
            while (rel && rel !== frameList && rel !== document.documentElement) {
                rel = rel.parentNode;
            }
            if (rel !== frameList) {
                close();
                evt.stopPropagation();
            }
        }
        function onFrameChange() {
            links.forEach(function(link) {
                link.className = parseInt(link.dataset.frameIndex) === player.currentFrameIndex ? "current" : "";
            });
        }
    }, {
        "../utils": 14,
        "./Animator": 4,
        "./Timing": 11
    } ],
    7: [ function(require, module, exports) {
        Object.defineProperty(exports, "__esModule", {
            value: true
        });
        exports.init = init;
        function _interopRequireWildcard(obj) {
            if (obj && obj.__esModule) {
                return obj;
            } else {
                var newObj = {};
                if (obj != null) {
                    for (var key in obj) {
                        if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key];
                    }
                }
                newObj["default"] = obj;
                return newObj;
            }
        }
        var _FrameList = require("./FrameList");
        var FrameList = _interopRequireWildcard(_FrameList);
        "use strict";
        function init(player) {
            var frameNumber = document.querySelector(".sozi-frame-number");
            player.addListener("frameChange", function() {
                frameNumber.innerHTML = player.currentFrameIndex + 1;
                frameNumber.style.visibility = player.currentFrame.showFrameNumber ? "visible" : "hidden";
            });
            frameNumber.addEventListener("click", FrameList.open);
        }
    }, {
        "./FrameList": 6
    } ],
    8: [ function(require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: true
        });
        exports.init = init;
        exports.getFrameIndex = getFrameIndex;
        var player;
        function init(aPlayer) {
            player = aPlayer;
            window.addEventListener("hashchange", onHashChange, false);
            player.addListener("frameChange", onFrameChange);
        }
        function getFrameIndex() {
            if (window.location.hash) {
                var indexOrId = window.location.hash.slice(1);
                var frame = player.presentation.getFrameWithId(indexOrId);
                if (frame) {
                    return frame.index;
                } else {
                    var index = parseInt(indexOrId);
                    return !isNaN(index) && index > 0 && index <= player.presentation.frames.length ? index - 1 : player.currentFrameIndex;
                }
            } else {
                return player.currentFrameIndex;
            }
        }
        function onHashChange() {
            var index = getFrameIndex();
            if (player.currentFrameIndex !== index) {
                player.moveToFrame(index);
            }
        }
        function onFrameChange() {
            window.location.hash = "#" + player.currentFrame.frameId;
        }
    }, {} ],
    9: [ function(require, module, exports) {
        Object.defineProperty(exports, "__esModule", {
            value: true
        });
        exports.init = init;
        var _utils = require("../utils");
        "use strict";
        var svgNs = "http://www.w3.org/2000/svg";
        var soziNs = "http://sozi.baierouge.fr";
        var xhtmlNs = "http://www.w3.org/1999/xhtml";
        var player;
        function defaultEventHandler(evt) {
            evt.stopPropagation();
        }
        var mediaToStartByFrameId = {};
        var mediaToStopByFrameId = {};
        function onFrameChange() {
            var frameId = player.currentFrame.frameId;
            if (frameId in mediaToStartByFrameId) {
                mediaToStartByFrameId[frameId].forEach(function(m) {
                    m.play();
                });
            }
            if (frameId in mediaToStopByFrameId) {
                mediaToStopByFrameId[frameId].forEach(function(m) {
                    m.pause();
                });
            }
        }
        function init(aPlayer) {
            player = aPlayer;
            player.addListener("frameChange", onFrameChange);
            var svgRoot = player.presentation.document.root;
            var svgAttributes = svgRoot.attributes;
            var soziPrefix;
            for (var attrIndex = 0; attrIndex < svgAttributes.length; attrIndex++) {
                if (svgAttributes[attrIndex].value === soziNs) {
                    soziPrefix = svgAttributes[attrIndex].name.slice(6);
                    break;
                }
            }
            if (!soziPrefix) {
                return;
            }
            var videoSources = svgRoot.getElementsByTagName(soziPrefix + ":video");
            var audioSources = svgRoot.getElementsByTagName(soziPrefix + ":audio");
            var mediaSources = (0, _utils.toArray)(videoSources).concat((0, _utils.toArray)(audioSources));
            var mediaList = [];
            mediaSources.forEach(function(source) {
                var rect = source.parentNode;
                var tagName = source.localName.slice(soziPrefix.length + 1);
                var htmlSource = document.createElementNS(xhtmlNs, "source");
                htmlSource.setAttribute("type", source.getAttribute(soziPrefix + ":type"));
                htmlSource.setAttribute("src", source.getAttribute(soziPrefix + ":src"));
                for (var j = 0; j < mediaList.length; j += 1) {
                    if (mediaList[j].rect === rect) {
                        break;
                    }
                }
                if (j === mediaList.length) {
                    rect.setAttribute("visibility", "hidden");
                    var htmlMedia = document.createElementNS(xhtmlNs, tagName);
                    htmlMedia.setAttribute("controls", "controls");
                    if (tagName === "video") {
                        htmlMedia.setAttribute("width", rect.getAttribute("width"));
                        htmlMedia.setAttribute("height", rect.getAttribute("height"));
                    }
                    htmlMedia.addEventListener("click", defaultEventHandler, false);
                    htmlMedia.addEventListener("mousedown", defaultEventHandler, false);
                    htmlMedia.addEventListener("mouseup", defaultEventHandler, false);
                    htmlMedia.addEventListener("mousemove", defaultEventHandler, false);
                    htmlMedia.addEventListener("contextmenu", defaultEventHandler, false);
                    var html = document.createElementNS(xhtmlNs, "html");
                    html.appendChild(htmlMedia);
                    var foreignObject = document.createElementNS(svgNs, "foreignObject");
                    foreignObject.setAttribute("x", rect.getAttribute("x"));
                    foreignObject.setAttribute("y", rect.getAttribute("y"));
                    foreignObject.setAttribute("width", rect.getAttribute("width"));
                    foreignObject.setAttribute("height", rect.getAttribute("height"));
                    foreignObject.appendChild(html);
                    rect.parentNode.insertBefore(foreignObject, rect.nextSibling);
                    if (source.hasAttribute(soziPrefix + ":start-frame")) {
                        var startFrameId = source.getAttribute(soziPrefix + ":start-frame");
                        var stopFrameId = source.getAttribute(soziPrefix + ":stop-frame");
                        if (!(startFrameId in mediaToStartByFrameId)) {
                            mediaToStartByFrameId[startFrameId] = [];
                        }
                        if (!(stopFrameId in mediaToStopByFrameId)) {
                            mediaToStopByFrameId[stopFrameId] = [];
                        }
                        mediaToStartByFrameId[startFrameId].push(htmlMedia);
                        mediaToStopByFrameId[stopFrameId].push(htmlMedia);
                    }
                    if (source.getAttribute(soziPrefix + ":loop") === "true") {
                        htmlMedia.setAttribute("loop", "true");
                    }
                    mediaList.push({
                        rect: source.parentNode,
                        htmlMedia: htmlMedia
                    });
                }
                mediaList[j].htmlMedia.appendChild(htmlSource);
            });
        }
    }, {
        "../utils": 14
    } ],
    10: [ function(require, module, exports) {
        Object.defineProperty(exports, "__esModule", {
            value: true
        });
        function _interopRequireWildcard(obj) {
            if (obj && obj.__esModule) {
                return obj;
            } else {
                var newObj = {};
                if (obj != null) {
                    for (var key in obj) {
                        if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key];
                    }
                }
                newObj["default"] = obj;
                return newObj;
            }
        }
        var _Animator = require("./Animator");
        var _Timing = require("./Timing");
        var Timing = _interopRequireWildcard(_Timing);
        var _modelCameraState = require("../model/CameraState");
        var _events = require("events");
        "use strict";
        var DEFAULT_TRANSITION_DURATION_MS = 500;
        var DEFAULT_RELATIVE_ZOOM = 0;
        var DEFAULT_TIMING_FUNCTION = "ease";
        var SCALE_FACTOR = 1.05;
        var ROTATE_STEP = 5;
        var Player = Object.create(_events.EventEmitter.prototype);
        exports.Player = Player;
        Player.init = function(viewport, presentation) {
            _events.EventEmitter.call(this);
            this.viewport = viewport;
            this.presentation = presentation;
            this.animator = Object.create(_Animator.Animator).init();
            this.playing = false;
            this.waitingTimeout = false;
            this.currentFrameIndex = 0;
            this.targetFrameIndex = 0;
            this.timeoutHandle = null;
            this.transitions = [];
            this.setupEventHandlers();
            return this;
        };
        Player.setupEventHandlers = function() {
            this.viewport.addListener("click", this.onClick.bind(this));
            this.viewport.addListener("dragStart", this.pause.bind(this));
            this.viewport.addListener("userChangeState", this.pause.bind(this));
            window.addEventListener("keydown", this.onKeyDown.bind(this), false);
            window.addEventListener("keypress", this.onKeyPress.bind(this), false);
            this.animator.addListener("step", this.onAnimatorStep.bind(this));
            this.animator.addListener("stop", this.onAnimatorStop.bind(this));
            this.animator.addListener("done", this.onAnimatorDone.bind(this));
            window.addEventListener("message", this.receiveMessage.bind(this), false);
            this.addListener("frameChange", this.sendFrameChange.bind(this));
        };
        Player.onClick = function(button) {
            switch (button) {
              case 0:
                this.moveToNext();
                break;

              case 2:
                this.moveToPrevious();
                break;
            }
        };
        Player.onKeyDown = function(evt) {
            if (evt.altKey || evt.ctrlKey || evt.metaKey) {
                return;
            }
            switch (evt.keyCode) {
              case 36:
                if (evt.shiftKey) {
                    this.jumpToFirst();
                } else {
                    this.moveToFirst();
                }
                break;

              case 35:
                if (evt.shiftKey) {
                    this.jumpToLast();
                } else {
                    this.moveToLast();
                }
                break;

              case 38:
              case 33:
              case 37:
                if (evt.shiftKey) {
                    this.jumpToPrevious();
                } else {
                    this.moveToPrevious();
                }
                break;

              case 40:
              case 34:
              case 39:
              case 13:
              case 32:
                if (evt.shiftKey) {
                    this.jumpToNext();
                } else {
                    this.moveToNext();
                }
                break;

              default:
                return;
            }
            evt.stopPropagation();
            evt.preventDefault();
        };
        Player.onKeyPress = function(evt) {
            if (evt.altKey || evt.ctrlKey || evt.metaKey) {
                return;
            }
            switch (evt.charCode || evt.which) {
              case 43:
                this.viewport.zoom(SCALE_FACTOR, this.viewport.width / 2, this.viewport.height / 2);
                this.pause();
                break;

              case 45:
                this.viewport.zoom(1 / SCALE_FACTOR, this.viewport.width / 2, this.viewport.height / 2);
                this.pause();
                break;

              case 82:
                this.viewport.rotate(-ROTATE_STEP);
                this.pause();
                break;

              case 114:
                this.viewport.rotate(ROTATE_STEP);
                this.pause();
                break;

              case 80:
              case 112:
                if (this.playing) {
                    this.pause();
                } else {
                    this.resume();
                }
                break;

              case 67:
              case 99:
                this.openRemoteControl();
                break;

              case 46:
                this.toggleBlankScreen();
                break;

              default:
                return;
            }
            evt.stopPropagation();
            evt.preventDefault();
        };
        Object.defineProperty(Player, "currentFrame", {
            get: function() {
                return this.presentation.frames[this.currentFrameIndex];
            }
        });
        Object.defineProperty(Player, "targetFrame", {
            get: function() {
                return this.presentation.frames[this.targetFrameIndex];
            }
        });
        Object.defineProperty(Player, "previousFrameIndex", {
            get: function() {
                var index = this.animator.running ? this.targetFrameIndex : this.currentFrameIndex;
                return (index + this.presentation.frames.length - 1) % this.presentation.frames.length;
            }
        });
        Object.defineProperty(Player, "nextFrameIndex", {
            get: function() {
                var index = this.animator.running ? this.targetFrameIndex : this.currentFrameIndex;
                return (index + 1) % this.presentation.frames.length;
            }
        });
        Player.showCurrentFrame = function() {
            this.viewport.setAtStates(this.currentFrame.cameraStates).update();
            this.emit("frameChange");
            return this;
        };
        Player.playFromIndex = function(index) {
            this.playing = true;
            this.waitingTimeout = false;
            this.targetFrameIndex = index;
            this.currentFrameIndex = index;
            this.showCurrentFrame();
            this.waitTimeout();
            return this;
        };
        Player.pause = function() {
            this.animator.stop();
            if (this.waitingTimeout) {
                window.clearTimeout(this.timeoutHandle);
                this.waitingTimeout = false;
            }
            this.playing = false;
            this.targetFrameIndex = this.currentFrameIndex;
            return this;
        };
        Player.resume = function() {
            this.playFromIndex(this.currentFrameIndex);
            return this;
        };
        Player.waitTimeout = function() {
            if (this.currentFrame.timeoutEnable) {
                this.waitingTimeout = true;
                this.timeoutHandle = window.setTimeout(this.moveToFrame.bind(this, this.nextFrameIndex), this.currentFrame.timeoutMs);
            }
            return this;
        };
        Player.jumpToFrame = function(index) {
            this.pause();
            this.targetFrameIndex = index;
            this.currentFrameIndex = index;
            this.showCurrentFrame();
            return this;
        };
        Player.jumpToFirst = function() {
            return this.jumpToFrame(0);
        };
        Player.jumpToLast = function() {
            return this.jumpToFrame(this.presentation.frames.length - 1);
        };
        Player.jumpToPrevious = function() {
            return this.jumpToFrame(this.previousFrameIndex);
        };
        Player.jumpToNext = function() {
            return this.jumpToFrame(this.nextFrameIndex);
        };
        Player.moveToFrame = function(index) {
            var _this = this;
            if (this.waitingTimeout) {
                window.clearTimeout(this.timeoutHandle);
                this.waitingTimeout = false;
            }
            this.targetFrameIndex = index;
            var layerProperties = null;
            var durationMs = DEFAULT_TRANSITION_DURATION_MS;
            var useTransitionPath = false;
            var backwards = false;
            if (index === this.nextFrameIndex) {
                durationMs = this.targetFrame.transitionDurationMs;
                layerProperties = this.targetFrame.layerProperties;
                useTransitionPath = true;
            } else if (index === this.previousFrameIndex) {
                durationMs = this.currentFrame.transitionDurationMs;
                layerProperties = this.currentFrame.layerProperties;
                useTransitionPath = true;
                backwards = true;
            }
            this.playing = true;
            this.viewport.cameras.forEach(function(camera) {
                var timingFunction = Timing[DEFAULT_TIMING_FUNCTION];
                var relativeZoom = DEFAULT_RELATIVE_ZOOM;
                var transitionPath = null;
                if (layerProperties) {
                    var lp = layerProperties[camera.layer.index];
                    relativeZoom = lp.transitionRelativeZoom;
                    timingFunction = Timing[lp.transitionTimingFunction];
                    if (useTransitionPath) {
                        transitionPath = lp.transitionPath;
                    }
                    if (backwards) {
                        timingFunction = timingFunction.reverse;
                    }
                }
                _this.setupTransition(camera, timingFunction, relativeZoom, transitionPath, backwards);
            });
            this.animator.start(durationMs);
            return this;
        };
        Player.moveToFirst = function() {
            return this.moveToFrame(0);
        };
        Player.moveToLast = function() {
            return this.moveToFrame(this.presentation.frames.length - 1);
        };
        Player.moveToPrevious = function() {
            for (var index = this.previousFrameIndex; index >= 0; index--) {
                var frame = this.presentation.frames[index];
                if (!frame.timeoutEnable || frame.timeoutMs !== 0) {
                    this.moveToFrame(index);
                    break;
                }
            }
            return this;
        };
        Player.moveToNext = function() {
            return this.moveToFrame(this.nextFrameIndex);
        };
        Player.moveToCurrent = function() {
            return this.moveToFrame(this.currentFrameIndex);
        };
        Player.previewFrame = function(index) {
            var _this2 = this;
            this.targetFrameIndex = index;
            this.viewport.cameras.forEach(function(camera) {
                _this2.setupTransition(camera, Timing[DEFAULT_TIMING_FUNCTION], DEFAULT_RELATIVE_ZOOM);
            });
            this.animator.start(DEFAULT_TRANSITION_DURATION_MS);
            return this;
        };
        Player.setupTransition = function(camera, timingFunction, relativeZoom, svgPath, reverse) {
            if (this.animator.running) {
                this.animator.stop();
            }
            this.transitions.push({
                camera: camera,
                initialState: Object.create(_modelCameraState.CameraState).initFrom(camera),
                finalState: this.targetFrame.cameraStates[camera.layer.index],
                timingFunction: timingFunction,
                relativeZoom: relativeZoom,
                svgPath: svgPath,
                reverse: reverse
            });
            return this;
        };
        Player.onAnimatorStep = function(progress) {
            this.transitions.forEach(function(transition) {
                transition.camera.interpolate(transition.initialState, transition.finalState, progress, transition.timingFunction, transition.relativeZoom, transition.svgPath, transition.reverse);
                transition.camera.update();
            });
        };
        Player.onAnimatorStop = function() {
            this.transitions = [];
            this.currentFrameIndex = this.targetFrameIndex;
            this.emit("frameChange");
        };
        Player.onAnimatorDone = function() {
            this.transitions = [];
            this.currentFrameIndex = this.targetFrameIndex;
            this.emit("frameChange");
            if (this.playing) {
                this.waitTimeout();
            }
        };
        Player.openRemoteControl = function() {
            if (typeof this.remoteControl == "undefined" || this.remoteControl.closed) {
                this.remoteControl = window.open("", "soziRemoteControl", "width=300, height=500");
                var source = document.getElementById("sozi-remote-control-source");
                this.remoteControl.document.write(source.value);
                var frameList = document.getElementsByClassName("sozi-frame-list")[0];
                this.remoteControl.document.write(frameList.outerHTML);
                this.remoteControl.postMessage(JSON.stringify({
                    action: "init"
                }), "*");
            } else {
                this.remoteControl.focus();
            }
        };
        Player.receiveMessage = function(event) {
            data = JSON.parse(event.data);
            switch (data.action) {
              case "moveToNext":
                this.moveToNext();
                break;

              case "moveToPrevious":
                this.moveToPrevious();
                break;

              case "keypress":
                this.triggerKey(data.keyCode, "keypress", data.shiftKey);
                break;

              case "keydown":
                this.triggerKey(data.keyCode, "keydown", data.shiftKey);
                break;

              case "moveToFrame":
                this.moveToFrame(data.frame);
                break;
            }
        };
        Player.sendFrameChange = function() {
            if (typeof this.remoteControl != "undefined" && !this.remoteControl.closed) {
                var json = JSON.stringify({
                    action: "frameChange",
                    previousFrameIndex: this.previousFrameIndex,
                    currentFrameIndex: this.currentFrameIndex,
                    nextFrameIndex: this.nextFrameIndex
                });
                this.remoteControl.postMessage(json, "*");
            }
        };
        Player.triggerKey = function(keyCode, event, shiftKey) {
            var el = document.body;
            var eventObj = document.createEventObject ? document.createEventObject() : document.createEvent("Events");
            if (eventObj.initEvent) {
                eventObj.initEvent(event, true, true);
            }
            eventObj.keyCode = keyCode;
            eventObj.which = keyCode;
            eventObj.shiftKey = shiftKey;
            el.dispatchEvent ? el.dispatchEvent(eventObj) : el.fireEvent("on" + event, eventObj);
        };
        Player.toggleBlankScreen = function() {
            var blankScreen = document.getElementById("sozi-blank-screen");
            if (blankScreen.style.opacity == 0) {
                blankScreen.style.visibility = "visible";
                blankScreen.style.opacity = 1;
            } else {
                blankScreen.style.opacity = 0;
                blankScreen.style.visibility = "hidden";
            }
        };
    }, {
        "../model/CameraState": 1,
        "./Animator": 4,
        "./Timing": 11,
        events: 15
    } ],
    11: [ function(require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: true
        });
        exports.makeBezier = makeBezier;
        exports.makeSteps = makeSteps;
        exports.stepMiddle = stepMiddle;
        function A(xy1, xy2) {
            return 1 - 3 * xy2 + 3 * xy1;
        }
        function B(xy1, xy2) {
            return 3 * xy2 - 6 * xy1;
        }
        function C(xy1) {
            return 3 * xy1;
        }
        function bezier(t, a, b, c) {
            return ((a * t + b) * t + c) * t;
        }
        function bezierSlope(t, a, b, c) {
            return (3 * a * t + 2 * b) * t + c;
        }
        function makeBezier(x1, y1, x2, y2) {
            var ax = A(x1, x2), bx = B(x1, x2), cx = C(x1);
            var ay = A(y1, y2), by = B(y1, y2), cy = C(y1);
            if (x1 === y1 && x2 === y2) {
                return function(x) {
                    return x;
                };
            }
            return function(x) {
                var t = x;
                for (var i = 0; i < 4; i++) {
                    var currentSlope = bezierSlope(t, ax, bx, cx);
                    if (currentSlope === 0) {
                        break;
                    }
                    var currentX = bezier(t, ax, bx, cx) - x;
                    t -= currentX / currentSlope;
                }
                return bezier(t, ay, by, cy);
            };
        }
        function makeSteps(n, direction) {
            var trunc = direction === "start" ? Math.ceil : Math.floor;
            return function(x) {
                return trunc(n * x) / n;
            };
        }
        var linear = makeBezier(0, 0, 1, 1);
        exports.linear = linear;
        linear.reverse = linear;
        var ease = makeBezier(.25, .1, .25, 1);
        exports.ease = ease;
        ease.reverse = ease;
        var easeIn = makeBezier(.42, 0, 1, 1);
        exports.easeIn = easeIn;
        var easeOut = makeBezier(0, 0, .58, 1);
        exports.easeOut = easeOut;
        easeIn.reverse = easeOut;
        easeOut.reverse = easeIn;
        var easeInOut = makeBezier(.42, 0, .58, 1);
        exports.easeInOut = easeInOut;
        easeInOut.reverse = easeInOut;
        var stepStart = makeSteps(1, "start");
        exports.stepStart = stepStart;
        var stepEnd = makeSteps(1, "end");
        exports.stepEnd = stepEnd;
        stepStart.reverse = stepEnd;
        stepEnd.reverse = stepStart;
        function stepMiddle(x) {
            return x >= .5 ? 1 : 0;
        }
        stepMiddle.reverse = stepMiddle;
    }, {} ],
    12: [ function(require, module, exports) {
        Object.defineProperty(exports, "__esModule", {
            value: true
        });
        var _Camera = require("./Camera");
        var _events = require("events");
        "use strict";
        var DRAG_BUTTON = 0;
        var DRAG_THRESHOLD_PX = 5;
        var SCALE_FACTOR = 1.05;
        var ROTATE_STEP = 5;
        var WHEEL_TIMEOUT_MS = 200;
        var CLIP_BORDER = 3;
        var Viewport = Object.create(_events.EventEmitter.prototype);
        exports.Viewport = Viewport;
        Viewport.init = function(presentation, editMode) {
            _events.EventEmitter.call(this);
            this.presentation = presentation;
            this.editMode = !!editMode;
            this.cameras = [];
            this.mouseDragX = 0;
            this.mouseDragY = 0;
            this.dragMode = "translate";
            this.clipMode = {
                cameras: [],
                operation: "select"
            };
            this.showHiddenElements = false;
            this.wheelTimeout = null;
            this.dragHandler = this.onDrag.bind(this);
            this.dragEndHandler = this.onDragEnd.bind(this);
            return this;
        };
        Viewport.makeUniqueId = function(prefix) {
            var suffix = Math.floor(1e3 * (1 + 9 * Math.random()));
            var id;
            do {
                id = prefix + suffix;
                suffix++;
            } while (this.svgRoot.getElementById(id));
            return id;
        };
        Viewport.onLoad = function() {
            var _this = this;
            this.svgRoot.addEventListener("mousedown", this.onMouseDown.bind(this), false);
            this.svgRoot.addEventListener("mousemove", this.onMouseMove.bind(this), false);
            this.svgRoot.addEventListener("contextmenu", this.onContextMenu.bind(this), false);
            var wheelEvent = "onwheel" in document.createElement("div") ? "wheel" : document.onmousewheel !== undefined ? "mousewheel" : "DOMMouseScroll";
            this.svgRoot.addEventListener(wheelEvent, this.onWheel.bind(this), false);
            this.cameras = this.presentation.layers.map(function(layer) {
                return Object.create(_Camera.Camera).init(_this, layer);
            });
            return this;
        };
        Object.defineProperty(Viewport, "svgRoot", {
            get: function() {
                return this.presentation.document.root;
            }
        });
        Viewport.getLayer = function(nodeId) {
            return this.layers.filter(function(layer) {
                return layer.nodeId === nodeId;
            })[0];
        };
        Viewport.onContextMenu = function(evt) {
            evt.stopPropagation();
            evt.preventDefault();
            this.emit("click", 2, evt);
        };
        Viewport.onMouseMove = function(evt) {
            if (this.dragMode === "clip") {
                switch (this.getClipMode(evt).operation) {
                  case "select":
                    this.svgRoot.style.cursor = "crosshair";
                    break;

                  case "n":
                  case "s":
                    this.svgRoot.style.cursor = "ns-resize";
                    break;

                  case "w":
                  case "e":
                    this.svgRoot.style.cursor = "ew-resize";
                    break;

                  case "nw":
                  case "se":
                    this.svgRoot.style.cursor = "nwse-resize";
                    break;

                  case "ne":
                  case "sw":
                    this.svgRoot.style.cursor = "nesw-resize";
                    break;

                  case "move":
                    this.svgRoot.style.cursor = "move";
                    break;

                  default:
                    this.svgRoot.style.cursor = "default";
                }
            } else {
                this.svgRoot.style.cursor = "default";
            }
        };
        Viewport.onMouseDown = function(evt) {
            evt.stopPropagation();
            evt.preventDefault();
            if (evt.button === DRAG_BUTTON) {
                this.mouseDragged = false;
                this.mouseDragX = this.mouseDragStartX = evt.clientX;
                this.mouseDragY = this.mouseDragStartY = evt.clientY;
                document.documentElement.addEventListener("mousemove", this.dragHandler, false);
                document.documentElement.addEventListener("mouseup", this.dragEndHandler, false);
                if (this.dragMode === "clip") {
                    this.clipMode = this.getClipMode(evt);
                }
            }
            this.emit("mouseDown", evt.button);
        };
        Viewport.getClipMode = function(evt) {
            var x = evt.clientX - this.x;
            var y = evt.clientY - this.y;
            var camerasByOperation = {
                nw: [],
                sw: [],
                ne: [],
                se: [],
                w: [],
                e: [],
                n: [],
                s: [],
                move: []
            };
            var selectedCameras = this.cameras.filter(function(camera) {
                return camera.selected;
            });
            selectedCameras.forEach(function(camera) {
                var rect = camera.clipRect;
                if (x >= rect.x - CLIP_BORDER && x <= rect.x + rect.width + CLIP_BORDER && y >= rect.y - CLIP_BORDER && y <= rect.y + rect.height + CLIP_BORDER) {
                    var w = x <= rect.x + CLIP_BORDER;
                    var e = x >= rect.x + rect.width - CLIP_BORDER - 1;
                    var n = y <= rect.y + CLIP_BORDER;
                    var s = y >= rect.y + rect.height - CLIP_BORDER - 1;
                    var operation = w || e || n || s ? (n ? "n" : s ? "s" : "") + (w ? "w" : e ? "e" : "") : "move";
                    camerasByOperation[operation].push(camera);
                }
            });
            for (var operation in camerasByOperation) {
                if (camerasByOperation[operation].length) {
                    return {
                        cameras: camerasByOperation[operation],
                        operation: operation
                    };
                }
            }
            return {
                cameras: selectedCameras,
                operation: "select"
            };
        };
        Viewport.onDrag = function(evt) {
            evt.stopPropagation();
            var xFromCenter = evt.clientX - this.x - this.width / 2;
            var yFromCenter = evt.clientY - this.y - this.height / 2;
            var angle = 180 * Math.atan2(yFromCenter, xFromCenter) / Math.PI;
            var translateX = evt.clientX;
            var translateY = evt.clientY;
            var zoom = Math.sqrt(xFromCenter * xFromCenter + yFromCenter * yFromCenter);
            var deltaX = evt.clientX - this.mouseDragX;
            var deltaY = evt.clientY - this.mouseDragY;
            if (!this.mouseDragged && (Math.abs(deltaX) > DRAG_THRESHOLD_PX || Math.abs(deltaY) > DRAG_THRESHOLD_PX)) {
                this.mouseDragged = true;
                this.rotateStart = this.rotatePrev = angle;
                this.translateStartX = this.translateXPrev = translateX;
                this.translateStartY = this.translateYPrev = translateY;
                this.zoomPrev = zoom;
                this.emit("dragStart");
            }
            if (this.mouseDragged) {
                var mode = this.dragMode;
                if (mode == "translate") {
                    if (evt.altKey) {
                        mode = "scale";
                    } else if (evt.shiftKey) {
                        mode = "rotate";
                    }
                }
                switch (mode) {
                  case "scale":
                    if (this.zoomPrev !== 0) {
                        this.zoom(zoom / this.zoomPrev, this.width / 2, this.height / 2);
                    }
                    this.zoomPrev = zoom;
                    break;

                  case "rotate":
                    if (evt.ctrlKey) {
                        angle = 10 * Math.round((angle - this.rotateStart) / 10) + this.rotateStart;
                    }
                    this.rotate(this.rotatePrev - angle);
                    this.rotatePrev = angle;
                    break;

                  case "clip":
                    switch (this.clipMode.operation) {
                      case "select":
                        this.clip(this.mouseDragStartX - this.x, this.mouseDragStartY - this.y, this.mouseDragX - this.x, this.mouseDragY - this.y);
                        break;

                      case "move":
                        this.clipRel(deltaX, deltaY, deltaX, deltaY);
                        break;

                      case "w":
                        this.clipRel(deltaX, 0, 0, 0);
                        break;

                      case "e":
                        this.clipRel(0, 0, deltaX, 0);
                        break;

                      case "n":
                        this.clipRel(0, deltaY, 0, 0);
                        break;

                      case "s":
                        this.clipRel(0, 0, 0, deltaY);
                        break;

                      case "nw":
                        this.clipRel(deltaX, deltaY, 0, 0);
                        break;

                      case "ne":
                        this.clipRel(0, deltaY, deltaX, 0);
                        break;

                      case "sw":
                        this.clipRel(deltaX, 0, 0, deltaY);
                        break;

                      case "se":
                        this.clipRel(0, 0, deltaX, deltaY);
                        break;
                    }
                    break;

                  default:
                    if (evt.ctrlKey) {
                        if (Math.abs(translateX - this.translateStartX) >= Math.abs(translateY - this.translateStartY)) {
                            translateY = this.translateStartY;
                        } else {
                            translateX = this.translateStartX;
                        }
                    }
                    this.translate(translateX - this.translateXPrev, translateY - this.translateYPrev);
                    this.translateXPrev = translateX;
                    this.translateYPrev = translateY;
                }
                this.mouseDragX = evt.clientX;
                this.mouseDragY = evt.clientY;
            }
        };
        Viewport.onDragEnd = function(evt) {
            evt.stopPropagation();
            evt.preventDefault();
            if (evt.button === DRAG_BUTTON) {
                if (this.mouseDragged) {
                    this.emit("dragEnd");
                    this.emit("userChangeState");
                } else {
                    this.emit("click", evt.button, evt);
                }
                document.documentElement.removeEventListener("mousemove", this.dragHandler, false);
                document.documentElement.removeEventListener("mouseup", this.dragEndHandler, false);
            } else {
                this.emit("click", evt.button, evt);
            }
        };
        Viewport.onWheel = function(evt) {
            var _this2 = this;
            if (this.wheelTimeout !== null) {
                window.clearTimeout(this.wheelTimeout);
            }
            evt.stopPropagation();
            evt.preventDefault();
            var delta = 0;
            if (evt.wheelDelta) {
                delta = evt.wheelDelta;
            } else if (evt.detail) {
                delta = -evt.detail;
            } else {
                delta = -evt.deltaY;
            }
            if (delta !== 0) {
                if (evt.shiftKey) {
                    this.rotate(delta > 0 ? ROTATE_STEP : -ROTATE_STEP);
                } else {
                    this.zoom(delta > 0 ? SCALE_FACTOR : 1 / SCALE_FACTOR, evt.clientX - this.x, evt.clientY - this.y);
                }
            }
            this.wheelTimeout = window.setTimeout(function() {
                _this2.wheelTimeout = null;
                _this2.emit("userChangeState");
            }, WHEEL_TIMEOUT_MS);
        };
        Object.defineProperty(Viewport, "x", {
            get: function() {
                return this.svgRoot.getScreenCTM().e;
            }
        });
        Object.defineProperty(Viewport, "y", {
            get: function() {
                return this.svgRoot.getScreenCTM().f;
            }
        });
        Object.defineProperty(Viewport, "width", {
            get: function() {
                return this.svgRoot === document.documentElement ? window.innerWidth : this.svgRoot.parentNode.clientWidth;
            }
        });
        Object.defineProperty(Viewport, "height", {
            get: function() {
                return this.svgRoot === document.documentElement ? window.innerHeight : this.svgRoot.parentNode.clientHeight;
            }
        });
        Viewport.repaint = function() {
            var _this3 = this;
            this.svgRoot.setAttribute("width", this.width);
            this.svgRoot.setAttribute("height", this.height);
            this.update();
            this.presentation.elementsToHide.forEach(function(id) {
                var elt = document.getElementById(id);
                if (elt) {
                    elt.style.visibility = _this3.showHiddenElements ? "visible" : "hidden";
                }
            });
            return this;
        };
        Viewport.update = function() {
            this.cameras.forEach(function(camera) {
                camera.update();
            });
            return this;
        };
        Viewport.setAtStates = function(states) {
            var _this4 = this;
            states.forEach(function(state, index) {
                _this4.cameras[index].initFrom(state);
            });
            return this;
        };
        Viewport.translate = function(deltaX, deltaY) {
            this.cameras.forEach(function(camera) {
                if (camera.selected) {
                    camera.translate(deltaX, deltaY);
                }
            });
            return this;
        };
        Viewport.zoom = function(factor, x, y) {
            this.cameras.forEach(function(camera) {
                if (camera.selected) {
                    camera.zoom(factor, x, y);
                }
            });
            return this;
        };
        Viewport.rotate = function(angle) {
            this.cameras.forEach(function(camera) {
                if (camera.selected) {
                    camera.rotate(angle);
                }
            });
            return this;
        };
        Viewport.clip = function(x0, y0, x1, y1) {
            this.clipMode.cameras.forEach(function(camera) {
                camera.clip(x0, y0, x1, y1);
            });
            return this;
        };
        Viewport.clipRel = function(w, n, e, s) {
            this.clipMode.cameras.forEach(function(camera) {
                var rect = camera.clipRect;
                if (w <= rect.width + e - 1 && n <= rect.height + s - 1) {
                    camera.clip(rect.x + w, rect.y + n, rect.x + rect.width + e - 1, rect.y + rect.height + s - 1);
                }
            });
            return this;
        };
    }, {
        "./Camera": 5,
        events: 15
    } ],
    13: [ function(require, module, exports) {
        Object.defineProperty(exports, "__esModule", {
            value: true
        });
        exports.registerHandler = registerHandler;
        var _utils = require("../utils");
        "use strict";
        var SVG_NS = "http://www.w3.org/2000/svg";
        var DRAWABLE_TAGS = [ "g", "image", "path", "rect", "circle", "ellipse", "line", "polyline", "polygon", "text", "clippath" ];
        var handlers = {};
        function registerHandler(name, handler) {
            handlers[name] = handler;
        }
        var DefaultHandler = {
            matches: function(svgRoot) {
                return true;
            },
            transform: function(svgRoot) {
                return this;
            },
            isLayer: function(svgElement) {
                return true;
            },
            getLabel: function(svgElement) {
                return null;
            }
        };
        exports.DefaultHandler = DefaultHandler;
        var SVGDocument = {
            asText: "",
            root: undefined,
            handler: DefaultHandler,
            init: function(svgRoot) {
                this.root = svgRoot;
                this.handler = DefaultHandler;
                for (var name in handlers) {
                    if (handlers[name].matches(svgRoot)) {
                        console.log("Using handler: " + name);
                        this.handler = handlers[name];
                        break;
                    }
                }
                return this;
            },
            get isValidSVG() {
                return this.root instanceof SVGSVGElement;
            },
            isLayer: function(svgNode) {
                return svgNode instanceof SVGGElement && svgNode.hasAttribute("id") && this.handler.isLayer(svgNode);
            },
            "import": function(data) {
                var _this = this;
                this.asText = "";
                this.root = undefined;
                var div = document.createElement("div");
                div.innerHTML = data;
                while (div.firstChild !== div.firstElementChild) {
                    div.removeChild(div.firstChild);
                }
                this.init(div.firstChild);
                if (this.isValidSVG) {
                    this.handler.transform(this.root);
                    this.root.removeAttribute("viewBox");
                    this.root.style.width = this.root.style.height = "auto";
                    var scripts = (0, _utils.toArray)(this.root.getElementsByTagName("script"));
                    scripts.forEach(function(script) {
                        script.parentNode.removeChild(script);
                    });
                    var links = (0, _utils.toArray)(this.root.getElementsByTagName("a"));
                    links.forEach(function(link) {
                        link.addEventListener("mousedown", function(evt) {
                            return evt.stopPropagation();
                        }, false);
                    });
                    var svgWrapper = document.createElementNS(SVG_NS, "g");
                    (0, _utils.toArray)(this.root.childNodes).forEach(function(svgNode) {
                        if (svgNode.tagName === undefined) {
                            _this.root.removeChild(svgNode);
                        } else if (DRAWABLE_TAGS.indexOf(svgNode.localName) >= 0) {
                            if (!_this.isLayer(svgNode)) {
                                svgWrapper.appendChild(svgNode);
                            } else if (svgWrapper.firstChild) {
                                _this.root.insertBefore(svgWrapper, svgNode);
                                svgWrapper = document.createElementNS(SVG_NS, "g");
                            }
                        }
                    });
                    if (svgWrapper.firstChild) {
                        this.root.appendChild(svgWrapper);
                    }
                    this.asText = div.innerHTML;
                    return this;
                }
            }
        };
        exports.SVGDocument = SVGDocument;
    }, {
        "../utils": 14
    } ],
    14: [ function(require, module, exports) {
        Object.defineProperty(exports, "__esModule", {
            value: true
        });
        exports.toArray = toArray;
        function toArray(collection) {
            return Array.prototype.slice.call(collection);
        }
    }, {} ],
    15: [ function(require, module, exports) {
        function EventEmitter() {
            this._events = this._events || {};
            this._maxListeners = this._maxListeners || undefined;
        }
        module.exports = EventEmitter;
        EventEmitter.EventEmitter = EventEmitter;
        EventEmitter.prototype._events = undefined;
        EventEmitter.prototype._maxListeners = undefined;
        EventEmitter.defaultMaxListeners = 10;
        EventEmitter.prototype.setMaxListeners = function(n) {
            if (!isNumber(n) || n < 0 || isNaN(n)) throw TypeError("n must be a positive number");
            this._maxListeners = n;
            return this;
        };
        EventEmitter.prototype.emit = function(type) {
            var er, handler, len, args, i, listeners;
            if (!this._events) this._events = {};
            if (type === "error") {
                if (!this._events.error || isObject(this._events.error) && !this._events.error.length) {
                    er = arguments[1];
                    if (er instanceof Error) {
                        throw er;
                    }
                    throw TypeError('Uncaught, unspecified "error" event.');
                }
            }
            handler = this._events[type];
            if (isUndefined(handler)) return false;
            if (isFunction(handler)) {
                switch (arguments.length) {
                  case 1:
                    handler.call(this);
                    break;

                  case 2:
                    handler.call(this, arguments[1]);
                    break;

                  case 3:
                    handler.call(this, arguments[1], arguments[2]);
                    break;

                  default:
                    len = arguments.length;
                    args = new Array(len - 1);
                    for (i = 1; i < len; i++) args[i - 1] = arguments[i];
                    handler.apply(this, args);
                }
            } else if (isObject(handler)) {
                len = arguments.length;
                args = new Array(len - 1);
                for (i = 1; i < len; i++) args[i - 1] = arguments[i];
                listeners = handler.slice();
                len = listeners.length;
                for (i = 0; i < len; i++) listeners[i].apply(this, args);
            }
            return true;
        };
        EventEmitter.prototype.addListener = function(type, listener) {
            var m;
            if (!isFunction(listener)) throw TypeError("listener must be a function");
            if (!this._events) this._events = {};
            if (this._events.newListener) this.emit("newListener", type, isFunction(listener.listener) ? listener.listener : listener);
            if (!this._events[type]) this._events[type] = listener; else if (isObject(this._events[type])) this._events[type].push(listener); else this._events[type] = [ this._events[type], listener ];
            if (isObject(this._events[type]) && !this._events[type].warned) {
                var m;
                if (!isUndefined(this._maxListeners)) {
                    m = this._maxListeners;
                } else {
                    m = EventEmitter.defaultMaxListeners;
                }
                if (m && m > 0 && this._events[type].length > m) {
                    this._events[type].warned = true;
                    console.error("(node) warning: possible EventEmitter memory " + "leak detected. %d listeners added. " + "Use emitter.setMaxListeners() to increase limit.", this._events[type].length);
                    if (typeof console.trace === "function") {
                        console.trace();
                    }
                }
            }
            return this;
        };
        EventEmitter.prototype.on = EventEmitter.prototype.addListener;
        EventEmitter.prototype.once = function(type, listener) {
            if (!isFunction(listener)) throw TypeError("listener must be a function");
            var fired = false;
            function g() {
                this.removeListener(type, g);
                if (!fired) {
                    fired = true;
                    listener.apply(this, arguments);
                }
            }
            g.listener = listener;
            this.on(type, g);
            return this;
        };
        EventEmitter.prototype.removeListener = function(type, listener) {
            var list, position, length, i;
            if (!isFunction(listener)) throw TypeError("listener must be a function");
            if (!this._events || !this._events[type]) return this;
            list = this._events[type];
            length = list.length;
            position = -1;
            if (list === listener || isFunction(list.listener) && list.listener === listener) {
                delete this._events[type];
                if (this._events.removeListener) this.emit("removeListener", type, listener);
            } else if (isObject(list)) {
                for (i = length; i-- > 0; ) {
                    if (list[i] === listener || list[i].listener && list[i].listener === listener) {
                        position = i;
                        break;
                    }
                }
                if (position < 0) return this;
                if (list.length === 1) {
                    list.length = 0;
                    delete this._events[type];
                } else {
                    list.splice(position, 1);
                }
                if (this._events.removeListener) this.emit("removeListener", type, listener);
            }
            return this;
        };
        EventEmitter.prototype.removeAllListeners = function(type) {
            var key, listeners;
            if (!this._events) return this;
            if (!this._events.removeListener) {
                if (arguments.length === 0) this._events = {}; else if (this._events[type]) delete this._events[type];
                return this;
            }
            if (arguments.length === 0) {
                for (key in this._events) {
                    if (key === "removeListener") continue;
                    this.removeAllListeners(key);
                }
                this.removeAllListeners("removeListener");
                this._events = {};
                return this;
            }
            listeners = this._events[type];
            if (isFunction(listeners)) {
                this.removeListener(type, listeners);
            } else {
                while (listeners.length) this.removeListener(type, listeners[listeners.length - 1]);
            }
            delete this._events[type];
            return this;
        };
        EventEmitter.prototype.listeners = function(type) {
            var ret;
            if (!this._events || !this._events[type]) ret = []; else if (isFunction(this._events[type])) ret = [ this._events[type] ]; else ret = this._events[type].slice();
            return ret;
        };
        EventEmitter.listenerCount = function(emitter, type) {
            var ret;
            if (!emitter._events || !emitter._events[type]) ret = 0; else if (isFunction(emitter._events[type])) ret = 1; else ret = emitter._events[type].length;
            return ret;
        };
        function isFunction(arg) {
            return typeof arg === "function";
        }
        function isNumber(arg) {
            return typeof arg === "number";
        }
        function isObject(arg) {
            return typeof arg === "object" && arg !== null;
        }
        function isUndefined(arg) {
            return arg === void 0;
        }
    }, {} ]
}, {}, [ 3 ]);</script>
        <textarea id="sozi-remote-control-source" style="display: none" disabled>
            <!-- This Source Code Form is subject to the terms of the Mozilla Public
   - License, v. 2.0. If a copy of the MPL was not distributed with this
   - file, You can obtain one at http://mozilla.org/MPL/2.0/. -->

<head>
    <title>Sozi remote control</title>
</head>
<body>
    <style type="text/css">
                body {
                    padding: 0;
                    margin: 0;
                }
                a div {
                    width: 46%;
                    height: 3em;
                    margin: 0.2em 2%;

                    float: left;
                    font-family: "Droid Sans", Helvetica, Arial, sans-serif;
                    font-size: 18pt;

                    text-align: center;
                    vertical-align: middle;
                    line-height: 3em;

                    color: rgb(240, 255, 255);
                    background-color: rgba(34, 34, 34, 0.9);
                    border-radius: 1em;
                }
                .sozi-frame-list {
                    width: 90%;
                    margin: 30px 0 0 0;
                    padding: 1em 5%;
                    overflow-y: auto;

                    list-style: decimal inside;

                    font-family: "Droid Sans", Helvetica, Arial, sans-serif;
                    font-size: 12pt;

                    color: rgb(240, 255, 255);
                    background-color: rgba(34, 34, 34, 0.9);
                    clear: both;
                    float: left;
                }

                .sozi-frame-list li {
                    margin: 0;
                    padding: 0;
                    overflow: hidden;
                    white-space: nowrap;
                    text-overflow: ellipsis;
                }

                .sozi-frame-list a {
                    color: inherit;
                    text-decoration: none;
                }

                .sozi-frame-list a:hover {
                    color: rgb(0, 204, 255);
                    text-decoration: underline;
                }
                
                .sozi-frame-list a.current {
                    color: rgb(255, 170, 68);
                }

                .sozi-frame-number {
                    position: absolute;
                    top: 0;
                    left: 1em;
                    text-align: center;
                    padding: 0.3em 0.6em;

                    cursor: pointer;

                    font-family: "Droid Sans", Helvetica, Arial, sans-serif;
                    font-size: 12pt;
                    color: rgb(240, 255, 255);
                    background-color: rgba(34, 34, 34, 0.9);
                }

                .sozi-frame-list img {
                    display: none;
                }

                #time {
                    width: 100%;
                    text-align: center;
                    font-size: 50pt;
                    font-family: "Droid Sans", Helvetica, Arial, sans-serif;
                    margin-top: 0.5em;
                    clear: both;
                    float: left;
                }
    </style>

    <a href="#" title="Move to previous frame" id="sozi-previous-button"><div>Previous</div></a>
    <a href="#" title="Move to next frame" id="sozi-next-button"><div>Next</div></a>

    <div><span id="time"></span></div>

    <a href="#" title="Stop stopwatch" id="sozi-stop-stopwatch"><div>Stop</div></a>
    <a href="#" title="Reset stopwatch" id="sozi-reset-stopwatch"><div>Reset</div></a>

    <script type="text/javascript">(function e(t, n, r) {
    function s(o, u) {
        if (!n[o]) {
            if (!t[o]) {
                var a = typeof require == "function" && require;
                if (!u && a) return a(o, !0);
                if (i) return i(o, !0);
                var f = new Error("Cannot find module '" + o + "'");
                throw f.code = "MODULE_NOT_FOUND", f;
            }
            var l = n[o] = {
                exports: {}
            };
            t[o][0].call(l.exports, function(e) {
                var n = t[o][1][e];
                return s(n ? n : e);
            }, l, l.exports, e, t, n, r);
        }
        return n[o].exports;
    }
    var i = typeof require == "function" && require;
    for (var o = 0; o < r.length; o++) s(r[o]);
    return s;
})({
    1: [ function(require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: true
        });
        exports.init = init;
        exports.start = start;
        exports.stop = stop;
        exports.reset = reset;
        exports.update = update;
        exports.toggle = toggle;
        var startAt = 0;
        var lapTime = 0;
        var isRunning = false;
        var $time;
        var clocktimer;
        var stopButton = document.getElementById("sozi-stop-stopwatch");
        function init() {
            stopButton.onclick = function() {
                toggle();
            };
            document.getElementById("sozi-reset-stopwatch").onclick = function() {
                reset();
            };
            show();
            start();
        }
        function now() {
            return new Date().getTime();
        }
        function start() {
            startAt = startAt ? startAt : now();
            isRunning = true;
            stopButton.firstChild.innerHTML = "Stop";
            stopButton.setAttribute("title", "Stop stopwatch");
            clocktimer = setInterval(update, 100);
        }
        function stop() {
            lapTime = startAt ? lapTime + now() - startAt : lapTime;
            startAt = 0;
            isRunning = false;
            stopButton.firstChild.innerHTML = "Start";
            stopButton.setAttribute("title", "Start stopwatch");
            clearInterval(clocktimer);
        }
        function reset() {
            lapTime = 0;
            startAt = 0;
            update();
            isRunning ? start() : stop();
        }
        function pad(num) {
            var s = "0000" + num;
            return s.substr(s.length - 2);
        }
        function formattedTime() {
            var time = lapTime + (startAt ? now() - startAt : 0);
            var hours = 0;
            var mins = 0;
            var secs = 0;
            var newTime = "";
            hours = Math.floor(time / (60 * 60 * 1e3));
            time = time % (60 * 60 * 1e3);
            mins = Math.floor(time / (60 * 1e3));
            time = time % (60 * 1e3);
            secs = Math.floor(time / 1e3);
            newTime = pad(hours) + ":" + pad(mins) + ":" + pad(secs);
            return newTime;
        }
        function show() {
            $time = document.getElementById("time");
            update();
        }
        function update() {
            $time.innerHTML = formattedTime();
        }
        function toggle() {
            isRunning ? stop() : start();
        }
    }, {} ],
    2: [ function(require, module, exports) {
        function _interopRequireWildcard(obj) {
            if (obj && obj.__esModule) {
                return obj;
            } else {
                var newObj = {};
                if (obj != null) {
                    for (var key in obj) {
                        if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key];
                    }
                }
                newObj["default"] = obj;
                return newObj;
            }
        }
        var _playerStopwatch = require("./player/Stopwatch");
        var Stopwatch = _interopRequireWildcard(_playerStopwatch);
        var _utils = require("./utils");
        "use strict";
        var links;
        function pm(data) {
            var json = JSON.stringify(data);
            parent.window.opener.postMessage(json, "*");
        }
        function init() {
            Stopwatch.init();
            document.getElementById("sozi-previous-button").onclick = function() {
                pm({
                    action: "moveToPrevious"
                });
            };
            document.getElementById("sozi-next-button").onclick = function() {
                pm({
                    action: "moveToNext"
                });
            };
            links = (0, _utils.toArray)(document.querySelectorAll(".sozi-frame-list li a"));
            links.forEach(function(link) {
                link.addEventListener("click", function(evt) {
                    if (evt.button === 0) {
                        var index = parseInt(link.dataset.frameIndex);
                        pm({
                            action: "moveToFrame",
                            frame: index
                        });
                        evt.preventDefault();
                    }
                });
            });
        }
        window.addEventListener("keydown", function(ev) {
            pm({
                action: "keydown",
                keyCode: ev.keyCode,
                shiftKey: ev.shiftKey
            });
        }, false);
        window.addEventListener("keypress", function(ev) {
            pm({
                action: "keypress",
                keyCode: ev.charCode || ev.which,
                shiftKey: ev.shiftKey
            });
        }, false);
        window.addEventListener("message", function(event) {
            data = JSON.parse(event.data);
            if (data.action == "frameChange") {
                links.forEach(function(link) {
                    link.className = parseInt(link.dataset.frameIndex) === data.currentFrameIndex ? "current" : "";
                });
            } else if (data.action == "init") {
                init();
            }
        }, false);
    }, {
        "./player/Stopwatch": 1,
        "./utils": 3
    } ],
    3: [ function(require, module, exports) {
        Object.defineProperty(exports, "__esModule", {
            value: true
        });
        exports.toArray = toArray;
        function toArray(collection) {
            return Array.prototype.slice.call(collection);
        }
    }, {} ]
}, {}, [ 2 ]);</script>
</body>

        </textarea>
    </body>
</html>
